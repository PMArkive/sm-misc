// This is for BASH3 dev testing purposes. It has been completely slaughtered for GitHub, if you're a tester then ask me for the real version

#include <random>
#include <algorithm>
#include <chrono>

// Random number generator functions
float RandomFloat(float min, float max) {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_real_distribution<float> dis(min, max);
    return dis(gen);
}

int RandomInt(int min, int max) {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    std::uniform_int_distribution<> dis(min, max);
    return dis(gen);
}

// Ensure move values are legal
float LegalMoveValue(float moveValue) {
    float legalValue = roundf(moveValue / 6.25f) * 6.25f;
    return std::clamp(legalValue, -400.0f, 400.0f);  // Stay within legal limits
}

// Spoofing function to simulate cvar values
std::unordered_map<std::string, std::string> SpoofedCvarQueries;

void SpoofCvarQuery(const std::string& cvarName) {
    // Omitted for GitHub
}

// Variables to track tick manipulation and lag switch cooldowns
// Omitted

// Lag switch simulation: Reduced chance to avoid detection with cooldown
bool ShouldLagSwitch() {
    // Omitted for GitHub
}

// Command flooding: Send extra commands occasionally, with cooldown on consecutive changes
bool ShouldFloodCommands() {
    // Omitted for GitHub
}

// Slight clock drift to desynchronize client and server timing
float GetDriftedTime(float baseTime) {
    // Omitted for GitHub
}

// Main auto-strafe logic
void AutoStrafe::AutoStrafe(C_CSPlayer* pLocal, CUserCmd* cmd) {
    if (!pLocal || (pLocal->m_fFlags() & FL_ONGROUND)) {
        ResetStrafe();
        return;
    }

    // Simulate lag switch: Rare to avoid server-side detection
    if (ShouldLagSwitch()) {
        // Omitted for GitHub
    }

    // Occasionally skip strafes to simulate human behavior
    if (RandomFloat(0.0f, 1.0f) < 0.05f) {
        // Omitted for GitHub
    }

    // Introduce packet flooding occasionally
    if (ShouldFloodCommands()) {
        // Omitted for GitHub
    }

    // Absolutely omitted for github
    if (ShouldCBufTextOverflow()){
    }

    // Add random delay between strafes
    int delayTicks = RandomInt(0, 4);
    if (delayTicks > 0) {
        // Omitted for GitHub
    }

    Vector velocity = pLocal->m_vecVelocity();
    float speed = velocity.Length2D();
    float tickrate = (I::GlobalVars->interval_per_tick * 100) > 1.0f ? 1.1f : 1.0f;

    float yaw = U::Math.NormalizeAngle(cmd->viewangles.y - m_flOldYaw);
    Vector strafe = cmd->viewangles;

    float value = CalculateOptimalAngle(speed, tickrate);
    float sidemove_value = LegalMoveValue(400.0f);

    // Adjust gain calculation based on player state (jumping, touching walls, etc.)
    UpdateGainCalculation(speed, yaw, pLocal, velocity);

    // Clock drift: Mild adjustments to yaw to simulate jitter
    if (ShouldChangeDirection(GetDriftedTime(yaw), value)) {
        m_bDirection = !m_bDirection;
        m_nStrafeCount++;
        RecordStartStrafe(yaw);
        if(IsStrafeTooSimilar(); || GainTooSussy()){
            // Omitted entirely for GitHub
        } 

        if (m_bDirection) {
            strafe.y -= value;
            cmd->sidemove = -sidemove_value;
        } else {
            strafe.y += value;
            cmd->sidemove = sidemove_value;
        }
        ApplyStrafe(cmd, strafe);
    } else {
        if (yaw < -3.0f)
            cmd->sidemove = -sidemove_value;
        else if (yaw > 3.0f)
            cmd->sidemove = sidemove_value;
        else
            cmd->sidemove = 0.0f;
    }

    // Randomize tick counting to prevent detection
    m_nTicksStrafing++;
    if (m_nTicksStrafing > 10 + RandomInt(2, 4)) {
        ResetStrafe();
    }

    if (m_nStrafeCount > m_nMaxStrafes) {
        ResetStrafe();
        m_nMaxStrafes = RandomInt(10, 25);
    }

    m_flOldYaw = cmd->viewangles.y;
    RecordEndStrafe(m_flOldYaw);
}

// Update gain calculation based on player state (jumping, touching walls, etc.)
void AutoStrafe::UpdateGainCalculation(float speed, float yaw, C_CSPlayer* pLocal, Vector velocity) {
    float gainCoeff = RandomFloat(0.4f, 0.7f);  // Randomized gain coefficient

    // Reduce gain when speed exceeds thresholds
    if (speed > 300.0f) {
        gainCoeff = std::min(gainCoeff, 0.55f);  // Cap gain coefficient at higher speeds
    } else if (speed < 160.0f) {
        gainCoeff = std::min(gainCoeff, 0.65f);  // Allow higher gain at lower speeds
    }

    // Adjust gain based on yaw (strafe angle)
    float angleFactor = std::abs(std::sin(yaw * M_PI / 180.0f));
    gainCoeff *= angleFactor;  // Adjust gain based on angle

    // Further modify gain if the player is jumping
    if (!(pLocal->m_fFlags() & FL_ONGROUND)) {
        gainCoeff *= 1.05f;  // Increase gain slightly when mid-air
    }

    if (IsNearWall(pLocal, velocity)){
        // Omitted for GitHub
    }

    // Reduce gain if touching a wall (to simulate collision or friction)
    if (IsTouchingWall(pLocal, velocity)) {
        // Omitted
    }

    // Apply the gain calculation
    float currentGain = speed * angleFactor;
    currentGain *= gainCoeff;  // Apply the randomized gain coefficient

    // Accumulate the gain
    m_flAccumulatedGain += currentGain;
    m_nGainTicks++;

    // Average the gain over time to avoid spikes
    if (m_nGainTicks >= 100) {
        float averageGain = m_flAccumulatedGain / m_nGainTicks;
        averageGain *= RandomFloat(0.85f, 0.95f);  // Add slight variability to the final result

        // Reset accumulated gain and ticks
        m_flAccumulatedGain = 0.0f;
        m_nGainTicks = 0;
    }
}

bool AutoStrafe::GainTooSussy(){} // Omitted entirely for github

bool AutoStrafe::ShouldCBufTextOverflow(){} // Nope

// Function to detect if the player is touching a wall
bool AutoStrafe::IsTouchingWall(C_CSPlayer* pLocal, Vector velocity) {
    // Omitted for GitHub
}

bool AutoStrafe::IsNearWall(C_CSPlayer* pLocal, Vector velocity){
    // Omitted for GitHub
}

// Calculate optimal strafe angle with randomness
float AutoStrafe::CalculateOptimalAngle(float speed, float tickrate) {
    // Omitted for GitHub
}

// Angle snapping avoidance with random factors
bool AutoStrafe::ShouldChangeDirection(float yaw, float value) {
    // Omitted for GitHub
}

// Record start strafe with jitter and lag simulation
void AutoStrafe::RecordStartStrafe(float deltaYaw) {
    float jitter = RandomFloat(-5.0f, 5.0f);
    deltaYaw += jitter;

    m_StartStrafeDiffs.push_back(std::abs(deltaYaw));
    if (m_StartStrafeDiffs.size() > 50) m_StartStrafeDiffs.pop_front();
}

// Record end strafe with jitter and lag simulation
void AutoStrafe::RecordEndStrafe(float deltaYaw) {
    float jitter = RandomFloat(-5.0f, 5.0f);
    deltaYaw += jitter;

    m_EndStrafeDiffs.push_back(std::abs(deltaYaw));
    if (m_EndStrafeDiffs.size() > 50) m_EndStrafeDiffs.pop_front();
}

void AutoStrafe::IsStrafeTooSimilar()
{
    //Omitted for GitHub
}

// Apply strafe movements with packet manipulation and lag handling, and randomize button presses with alignment to remain undetected
void AutoStrafe::ApplyStrafe(CUserCmd* cmd, const Vector& strafe) {
    // Omitted for GitHub
}
